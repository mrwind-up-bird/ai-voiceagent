---
title: "Building Privacy-First Device Sync: No Servers, No Storage, No Compromise"
date: 2026-02-06
tags: [rust, privacy, webrtc, crdt, mobile-sync, tauri]
excerpt: "Designing ephemeral device synchronization for Aurus Voice Intelligence where privacy isn't a feature—it's the architecture. Here's how we're building sync that forgets everything by design."
---

# Building Privacy-First Device Sync: No Servers, No Storage, No Compromise

Last night, I sat down to design Phase 5 of [Aurus Voice Intelligence](https://github.com/yourusername/aurus-voiceintelligence)—device synchronization between desktop and mobile. Simple enough, right? Just sync some preferences and session state across devices. 

Except there was one non-negotiable constraint: **don't store any data**.

Not "encrypt it really well." Not "delete it after 30 days." Not even "anonymize it." Just... don't store it. Period.

This single constraint transformed what could have been a weekend Yjs + Firebase project into an architecture deep-dive that taught me more about privacy-first design than any conference talk ever could.

## The Problem Space

Aurus is a voice intelligence app for capturing spontaneous thoughts. Users record audio, get real-time transcription, and manage their recordings across sessions. Now we want to sync preferences, active sessions, and UI state between desktop and mobile—seamlessly, instantly, and without compromising the core privacy promise.

The challenge? Most sync solutions are built around **persistence**:
- Yjs typically uses IndexedDB or localStorage
- Firebase, Supabase, and friends store everything server-side
- Even "local-first" often means "local SQLite that syncs to the cloud"

But for Aurus, we can't afford a data breach because **there's no data to breach**.

## The Architecture Hunt

I started where most developers would: Yjs + y-webrtc seemed perfect. CRDT-based conflict-free sync, WebRTC for peer-to-peer connections, and a mature ecosystem. But then I hit the first wall.

### Lesson #1: JavaScript Can't Forget

JavaScript heap memory isn't designed for secure erasure. Even if you null out your variables, V8's garbage collector decides when (or if) that memory gets reclaimed. For an Electron/Tauri app handling sensitive session state, this wasn't good enough.

**The pivot:** Move sync logic entirely into Rust. Tauri's backend gives us:
- Explicit memory control with `zeroize` crate
- Secure random number generation via `ring`
- Type safety between Rust backend and TypeScript frontend
- Memory that actually gets wiped when we say so

### Lesson #2: CRDTs Don't Require Databases

This was the lightbulb moment. I'd mentally coupled CRDTs with persistence—Yjs stores its Y.Doc somewhere, right? But then I discovered [yrs](https://github.com/y-crdt/y-crdt), the Rust port of Yjs, and realized:

**A CRDT is just an in-memory data structure.**

```rust
use yrs::{Doc, Map, Transact};

// Create an ephemeral document
let doc = Doc::new();
let map = doc.get_or_insert_map("preferences");

{
    let mut txn = doc.transact_mut();
    map.insert(&mut txn, "theme", "dark");
    // When txn drops, changes are ready to sync
}

// No .save(). No .persist(). Just... exists in RAM.
```

When the app closes, the Y.Doc evaporates. The only "storage" is whatever's currently synced to the other device—which is also in RAM.

## The Security Stack

With the core insight established, I dove into the security architecture. Here's what emerged from research and a very thorough conversation with Gemini's security analysis:

### Layer 1: Discovery (mDNS)
Devices on the same local network find each other via multicast DNS—no server required. Think AirDrop, but for sync.

```rust
use mdns_sd::{ServiceDaemon, ServiceInfo};

let mdns = ServiceDaemon::new()?;
let service = ServiceInfo::new(
    "_aurus._udp.local.",
    "aurus-desktop-a3f2",
    "local.",
    "192.168.1.42",
    5353,
    None
)?;
mdns.register(service)?;
```

### Layer 2: Pairing (SPAKE2+)
When a user wants to connect devices, they get a **human-readable pairing code** like `4-purple-castle`. Both devices input this, and SPAKE2+ (a password-authenticated key exchange) establishes a shared secret—even over an untrusted network.

```rust
use spake2::{Ed25519Group, Identity, Password, Spake2};

let (s1, outbound_msg) = Spake2::<Ed25519Group>::start_symmetric(
    &Password::new(b"4-purple-castle"),
    &Identity::new(b"device-pairing"),
);
// Exchange outbound_msg with peer...
let key_material = s1.finish(&inbound_msg)?;
```

No QR codes to screenshot. No links to intercept. Just six words you read aloud.

### Layer 3: Transport (WebRTC)
Once paired, devices establish a direct peer-to-peer WebRTC connection:
- **DTLS encryption** (built into WebRTC)
- **No relay** for local network (STUN only)
- **Minimal signaling server** for cross-network (more on this pain point below)

```rust
use webrtc::api::APIBuilder;
use webrtc::peer_connection::RTCPeerConnection;

let api = APIBuilder::new().build();
let pc = api.new_peer_connection(rtc_config).await?;

// ICE candidates, SDP exchange, then pure P2P data channels
```

### Layer 4: Application Encryption (AES-256-GCM)
Even though WebRTC encrypts the transport, we add a second layer using the SPAKE2+ shared secret:

```rust
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

let key = LessSafeKey::new(UnboundKey::new(&AES_256_GCM, &key_material)?);
let nonce = Nonce::assume_unique_for_key(nonce_bytes);
key.seal_in_place_append_tag(nonce, Aad::empty(), &mut plaintext)?;
```

This "double encryption" means:
1. A compromised WebRTC implementation doesn't leak data
2. A malicious signaling server only sees encrypted blobs
3. Even memory dumps mid-sync show only ciphertext

### Layer 5: Session Lifecycle
The final piece: **make forgetting automatic**.

```rust
// Dead man's switch: if no activity for 2min, close connection
tokio::spawn(async move {
    let mut interval = tokio::time::interval(Duration::from_secs(120));
    loop {
        interval.tick().await;
        if last_activity.elapsed() > Duration::from_secs(120) {
            connection.close().await;
            doc.destroy(); // Explicit Y.Doc cleanup
            break;
        }
    }
});
```

- **Max session duration:** 4 hours
- **Key rotation:** Every 30 minutes
- **Inactivity timeout:** 2 minutes
- **On disconnect:** All sync state is securely wiped

## The Signaling Server Problem

Here's the honest pain point: **WebRTC needs signaling for cross-network connections.**

For devices on the same WiFi, mDNS + local IP direct connection works perfectly. But for "sync my phone over cellular to my desktop at home," you need a way to exchange ICE candidates and SDP offers.

### The Compromise

We're building an **opaque relay server**:
- Devices send encrypted blobs (pre-encrypted with SPAKE2+ session keys)
- Server just stores `device_id -> blob` mappings for 60 seconds
- No TLS termination, no payload inspection, no logging beyond connection metadata
- Self-hostable via Docker for paranoid users

```rust
// Signaling message (server sees only ciphertext)
let signal_msg = SignalingMessage {
    device_id: uuid::Uuid::new_v4(),
    payload: encrypted_sdp_offer, // Already encrypted!
    expires_at: Utc::now() + Duration::seconds(60),
};
```

It's not zero-server (I tried, WebRTC won't let me), but it's zero-knowledge. The server is as dumb as architecturally possible.

## The Implementation Plan

With architecture locked in, here's the phased rollout:

### Phase 5a: Foundation (In-Memory CRDT)
- Add `yrs`, `uuid`, `ring`, `rand` crates
- Create `sync/document.rs` with ephemeral Y.Doc
- Build `encryption.rs` with key derivation + AES-GCM
- Wire Zustand store to Y.Map observers

### Phase 5b: Local Discovery & Pairing
- Add `mdns-sd`, `spake2` crates
- Build mDNS advertisement/discovery
- Create pairing UI with 6-word codes
- Implement SPAKE2+ key exchange

### Phase 5c: WebRTC Transport
- Add `webrtc` crate (v0.11, tokio-native)
- Build data channel management
- Deploy minimal signaling relay
- Handle ICE candidate exchange

### Phase 5d: Session Security
- Implement dead man's switch
- Add 4-hour max session timeout
- Build 30-minute key rotation
- Create secure shutdown with memory wiping

## Why This Matters

Privacy-first architecture isn't about adding encryption as an afterthought. It's about designing systems where **privacy violations are architecturally impossible**.

When you can't store data, you can't:
- Have a data breach
- Comply with a subpoena for data that doesn't exist
- Accidentally leak data through misconfigured S3 buckets
- Build "anonymized" datasets that get de-anonymized

The best security is the absence of attack surface.

## What's Next

The plan is written (all 400+ lines in [`declarative-baking-whistle.md`](https://github.com/yourusername/aurus-voiceintelligence/tree/main/.claude/plans)). Tests are green. Build is clean. 

Now comes the fun part: implementing this monster.

I'll be documenting the journey—successes, failures, and "why is WebRTC like this" moments—as we build. If you're interested in privacy-first architecture, Rust + Tauri patterns, or just want to watch someone potentially fail spectacularly at reinventing Firebase, follow along.

And if you've built something similar (or think I'm crazy), I'd love to hear about it. The architecture is solid, but implementation always teaches lessons that design can't predict.

---

**Current status:** Architecture approved, dependencies mapped, 11 new files queued for creation. First commit incoming.

**Stack:** Rust, Tauri, TypeScript, yrs, webrtc-rs, SPAKE2+, mDNS  
**Repo:** [github.com/yourusername/aurus-voiceintelligence](https://github.com/yourusername/aurus-voiceintelligence) *(replace with actual URL)*

*This post is part of a series documenting the development of Aurus Voice Intelligence. Previous: [Phase 4 - Mobile Build Architecture](link). Next: Phase 5a implementation begins.*