---
title: "Going Cross-Platform: Migrating a Desktop Voice App to Mobile"
date: 2026-02-04
tags: [rust, tauri, mobile-development, cross-platform, security, ios, android]
excerpt: "How we transformed Aurus Voice Intelligence from a desktop-only application into a cross-platform powerhouse—and the hard lessons we learned about secure credential storage along the way."
---

# Going Cross-Platform: Migrating a Desktop Voice App to Mobile

There's a special kind of ambition that strikes when you've just shipped a desktop app and someone asks, "Does it work on mobile?" What starts as a simple question quickly becomes a deep dive into platform abstractions, security models, and build system quirks.

This is the story of migrating **Aurus Voice Intelligence**—a Tauri-based voice application built with Rust and Next.js—from desktop-only to a truly cross-platform architecture that works on macOS, Windows, Linux, iOS, and Android.

## The Challenge

Our starting point was solid: a working desktop application using Tauri's powerful Rust backend with a Next.js frontend. But mobile support meant rethinking some fundamental assumptions:

- **Security Model**: Our API keys were stored in a JSON file. Fine for desktop development, completely unacceptable for production mobile apps.
- **Platform APIs**: Features like audio processing and speech synthesis had desktop-specific implementations that wouldn't translate to mobile.
- **Build System**: Tauri's configuration needed to accommodate multiple platforms with different capabilities.

## Phase 1: Building the Foundation

### The Security Wake-Up Call

The first and most critical task was fixing our credential storage. Storing API keys in plaintext JSON files might fly in early development, but it's a non-starter for any production application—especially mobile.

We needed platform-native secure storage:
- **macOS/iOS**: Keychain via the `security-framework` crate
- **Windows**: Credential Manager via the `windows` crate
- **Linux**: Secret Service (GNOME Keyring) via the `secret-service` crate
- **Android**: Android Keystore via JNI and EncryptedSharedPreferences

The solution? A unified abstraction layer. We created a `SecureStorage` trait that provides a consistent interface across all platforms:

```rust
pub trait SecureStorage {
    fn store(&self, key: &str, value: &str) -> Result<()>;
    fn retrieve(&self, key: &str) -> Result<String>;
    fn delete(&self, key: &str) -> Result<()>;
}
```

Then we implemented platform-specific backends in `src-tauri/src/platform/secrets/`:
- `apple.rs` for macOS and iOS Keychain integration
- `windows.rs` for Windows Credential Manager
- `linux.rs` for the freedesktop.org Secret Service API
- `android.rs` for Android's encrypted storage

Our main `secrets.rs` module now delegates to the appropriate platform implementation at compile time. The same Rust code that runs on desktop seamlessly uses the iOS Keychain when compiled for mobile.

### Platform-Specific Features

Not every feature makes sense on every platform. Audio processing with the CPAL library works great on desktop but needs native bridges on mobile. Speech synthesis has different implementations across platforms.

We used Rust's conditional compilation to handle this gracefully:

```rust
#[cfg(not(target_os = "android"))]
pub mod audio;

#[cfg(not(target_os = "android"))]
pub mod tts;

#[cfg(desktop)]
pub mod transcription;
```

This lets us maintain a single codebase while compiling only the relevant code for each target platform.

## Lessons Learned (The Hard Way)

### Lesson 1: Don't Fight Tauri's Build System

**The Problem**: In an attempt to be clever, we tried splitting the `tauri` dependency in `Cargo.toml` into target-specific sections. The goal was to remove the `macos-private-api` feature flag on non-macOS platforms.

**The Reality**: Tauri's build script expects dependency features to match `tauri.conf.json` exactly, regardless of the target platform. The build failed spectacularly.

**The Solution**: Keep all Tauri features in the main dependency section. Features that don't apply to a platform are simply ignored by that platform's build. Don't overthink it.

```toml
# Do this
[dependencies]
tauri = { version = "2.1.1", features = ["macos-private-api", "tray-icon"] }

# Not this
[target.'cfg(target_os = "macos")'.dependencies]
tauri = { version = "2.1.1", features = ["macos-private-api"] }
```

### Lesson 2: When in Doubt, Clean Your Build

**The Problem**: After making significant structural changes, we ran `cargo check` and got cryptic errors about "failed to read plugin permissions" pointing to a non-existent project path.

**The Reality**: Cargo's build cache had become stale, still referencing the old project structure and file paths.

**The Solution**: `cargo clean` is your friend. When you make major architectural changes—especially to directory structure or build configuration—start with a clean slate.

This seems obvious in retrospect, but when you're deep in debugging mode, it's easy to assume the error message is pointing to a real problem rather than a stale cache.

## Current Status and What's Next

We've successfully completed the security infrastructure and platform abstraction layers. All 33 tests pass, and the desktop release build works perfectly. Users will need to manually migrate their API keys from the old JSON file to the secure storage (we're considering adding a migration command to automate this).

The immediate roadmap:

1. **Mobile Build Configuration**: Adding iOS bundle identifiers, Android package names, and platform-specific permissions to `tauri.conf.json`
2. **WebView Compatibility**: Ensuring our Next.js static export plays nicely with mobile WebView constraints
3. **CI/CD Pipeline**: Setting up GitHub Actions to build and sign iOS and Android releases
4. **Audio Bridge**: Evaluating CPAL alternatives for mobile or implementing native audio bridges

## Takeaways for Your Cross-Platform Journey

If you're considering a similar migration, here's what we'd tell our past selves:

1. **Start with security**: Don't postpone secure credential storage. It only gets harder to retrofit later.
2. **Embrace platform abstractions early**: Even if you're only targeting one platform today, design with multiple platforms in mind.
3. **Test incrementally**: We ran tests after each platform implementation. Catching issues early saved hours of debugging.
4. **Document your pain**: Those "weird errors" you encountered? Write them down. Future you (or your teammates) will thank you.
5. **Trust the framework**: Tauri's conventions exist for good reasons. Work with them, not against them.

Cross-platform development is challenging, but with careful architecture and platform-specific abstractions, it's entirely achievable. The key is accepting that "write once, run anywhere" is a myth—but "architect once, implement per-platform" is a very attainable reality.

---

*Aurus Voice Intelligence is an ongoing project exploring the intersection of voice interfaces, AI, and cross-platform development. Follow along as we continue building in public and sharing what we learn.*