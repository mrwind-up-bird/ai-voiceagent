---
title: "Building Cross-Platform AI Voice Apps: Migrating from Desktop to Mobile"
date: 2026-02-05
tags: [tauri, rust, mobile-development, cross-platform, ai, webassembly, react]
excerpt: "How we migrated Aurus Voice Intelligence from desktop-only to a cross-platform architecture supporting iOS and Android, while adding on-device AI and fixing security vulnerabilities along the way."
---

# Building Cross-Platform AI Voice Apps: Migrating from Desktop to Mobile

When we started building Aurus Voice Intelligence, we took the path many desktop apps take: Tauri + Next.js for a fast, native-feeling experience on macOS, Windows, and Linux. But as users started asking for mobile versions, we faced a common dilemma: rewrite everything, or find a way to share our existing codebase?

We chose the harder but more rewarding path: evolving our architecture to support mobile while keeping our desktop builds intact. Here's what we learned along the way.

## The Challenge: More Than Just "Make It Mobile"

Our migration wasn't just about getting the app running on phones. We had three parallel goals:

1. **Cross-platform support** - iOS and Android without abandoning desktop
2. **Security fixes** - Our API keys were stored in plain JSON files (yikes!)
3. **On-device AI** - Add local transcription and summarization to reduce server costs

Each of these could be a project on its own. Together, they required rethinking our entire architecture.

## Phase 1: Platform Abstraction Layer

The first lesson: **you can't write platform-specific code until you have a platform abstraction**.

We created a Rust module that defines common interfaces for platform-specific features. The most critical was secure storage:

```rust
// src-tauri/src/platform/secrets/mod.rs
pub trait SecureStorage: Send + Sync {
    fn store(&self, key: &str, value: &str) -> Result<(), String>;
    fn retrieve(&self, key: &str) -> Result<String, String>;
    fn delete(&self, key: &str) -> Result<(), String>;
}
```

Then we implemented this trait for each platform:
- **macOS/iOS**: Keychain via `security-framework` crate
- **Windows**: Credential Manager via `windows` crate
- **Linux**: Secret Service API via `secret-service` crate
- **Android**: Android Keystore (stub for now, needs JNI)

This pattern gave us a single API in our business logic layer that "just works" regardless of where the app runs.

## Phase 2: Security Migration

With the abstraction in place, we rewrote our secrets management system. Instead of:

```typescript
// ❌ Old way: Plain JSON file
const apiKeys = JSON.parse(fs.readFileSync('.api_keys'));
```

We now use:

```rust
// ✅ New way: Platform-specific secure storage
let api_key = platform::secrets::get_storage().retrieve("openai_api_key")?;
```

The beauty of this approach? Our frontend code doesn't know or care where secrets are stored. It just calls the same Tauri command on every platform.

## Phase 4: Bringing AI to the Edge

One of our most exciting additions was on-device AI using [Transformers.js](https://huggingface.co/docs/transformers.js). We wanted users to transcribe short audio clips and summarize notes without sending data to our servers.

We built a Web Worker to handle inference without blocking the UI:

```typescript
// app/workers/ai-worker.ts
import { pipeline } from '@xenova/transformers';

const transcriber = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny.en');
const summarizer = await pipeline('summarization', 'Xenova/distilbart-cnn-6-6');
```

Then wrapped it in a React hook for easy use:

```typescript
// app/hooks/useLocalAI.ts
const { transcribe, summarize, isReady } = useLocalAI();

const result = await transcribe(audioBlob);
```

The first load downloads ~40MB of models, but after that, everything runs locally in WebAssembly. No API costs, no privacy concerns, and it works offline.

## Lessons Learned (The Hard Way)

### Lesson 1: Tauri Features Are Inflexible

We tried to be clever with conditional Cargo features:

```toml
[target.'cfg(target_os = "macos")'.dependencies]
tauri = { version = "2.1", features = ["macos-private-api"] }
```

**This doesn't work.** Tauri's build script validates that features in `Cargo.toml` exactly match `tauri.conf.json`. The workaround: keep features in the main `[dependencies]` section. Cargo ignores platform-specific features gracefully anyway.

### Lesson 2: macOS Error Messages Are Verbose

When checking if a Keychain item exists, we pattern-matched on "not found". But the actual error was:

> "The specified item could not be found in the keychain."

Our initial pattern was too strict. The fix:

```rust
// ❌ Too strict
if msg == "not found" { ... }

// ✅ Works with verbose messages
if msg.contains("could not be found") { ... }
```

**Takeaway**: Use broad pattern matching for system error messages.

### Lesson 3: Library Versions Matter (A Lot)

We followed Transformers.js v3 documentation, but our project used v2.17:

```typescript
// ❌ v3 API (doesn't exist in v2)
pipeline('asr', 'model', { dtype: 'fp32', device: 'wasm' });

// ✅ v2 API (simpler)
pipeline('automatic-speech-recognition', 'model');
```

The v2 API is actually simpler—no manual device selection needed. But we spent an hour debugging TypeScript errors before realizing the docs were for a different major version.

**Takeaway**: Always check the docs version matches your installed package.

### Lesson 4: TypeScript Export Gotchas

We declared interfaces with `export interface` at the top of the file, then tried to re-export them at the bottom:

```typescript
export interface WorkerMessage { ... }

// Later in the file...
export type { WorkerMessage }; // ❌ Conflict!
```

**Takeaway**: `export interface` at declaration is sufficient. Don't re-export.

## What's Next

We've completed the foundation, security, and AI infrastructure. The remaining pieces:

1. **Mobile audio capture** - Evaluating Tauri plugins vs custom native bridges
2. **Data sync** - Designing a Yjs + WebRTC architecture for desktop ↔ mobile sync
3. **Mobile testing** - Setting up CI/CD with iOS and Android builds
4. **Production testing** - Validating Transformers.js performance on real devices

## Key Takeaways

If you're considering a similar migration, here's what matters most:

✅ **Start with abstraction** - Platform-specific code should be isolated behind traits/interfaces  
✅ **Security first** - Never store secrets in plain files, even during development  
✅ **Use conditional compilation** - `#[cfg(target_os = "...")]` in Rust keeps code clean  
✅ **Web Workers for AI** - Keep heavy inference off the main thread  
✅ **Document the pain** - Future you will thank past you for writing down what didn't work

Building cross-platform apps is complex, but with the right architecture, you can share 90% of your codebase while still delivering native experiences on every platform.

---

**Want to follow along?** We'll be sharing more updates as we tackle mobile audio capture and real-time sync. The challenges are far from over, but that's what makes it interesting.

*Have you migrated a desktop app to mobile? What was your biggest challenge? Let me know in the comments or reach out on Twitter.*