---
title: "Building Real-Time Device Sync: Wiring the Frontend UI"
date: 2026-02-07
tags: [tauri, webrtc, real-time-sync, frontend, react, typescript]
excerpt: "The final piece of the puzzle: building an intuitive pairing modal and wiring up auto-sync for seamless device-to-device communication in a Tauri desktop app."
---

# Building Real-Time Device Sync: Wiring the Frontend UI

After building out the entire backend infrastructure for device-to-device synchronization—WebRTC connections, signaling servers, and bidirectional sync channels—it was finally time to bring it all to life in the user interface. This is the story of Phase 5's final session: wiring up the sync UI.

## The Goal

Create an intuitive pairing experience that lets users:
- Generate a one-time pairing code on one device
- Enter that code on another device to establish a connection
- See real-time connection status
- Automatically sync transcript data and agent results between devices

All of this needed to feel seamless, with clear visual feedback at every step.

## The Building Blocks

One of the satisfying parts of this session was discovering how well the groundwork paid off. The infrastructure was already in place:

- **`useSync()` hook**: Seven Tauri event listeners for connection lifecycle events
- **`SyncStatus` component**: A status badge showing connection state
- **Store state**: All the sync-related state fields in Zustand
- **Backend commands**: Create session, join session, disconnect, sync data

The frontend just needed to orchestrate these pieces into a coherent user experience.

## Designing the Pairing Flow

The pairing modal needed to handle four distinct connection states:

### 1. Disconnected State
The starting point: a clean choice between creating a new session or joining an existing one.

```typescript
{status === 'disconnected' && (
  <>
    <button onClick={handleCreateSession}>
      Create Session
    </button>
    <input
      placeholder="Enter pairing code"
      value={joinCode}
      onChange={(e) => setJoinCode(e.target.value)}
    />
    <button onClick={handleJoinSession}>
      Join Session
    </button>
  </>
)}
```

### 2. Waiting for Peer
After creating a session, show the generated pairing code with a click-to-copy feature. Added a helpful note that codes expire after 60 seconds to set expectations.

```typescript
{status === 'waiting_for_peer' && pairingCode && (
  <>
    <div onClick={() => navigator.clipboard.writeText(pairingCode)}>
      {pairingCode}
    </div>
    <p>Share this code with your other device</p>
    <small>Code expires in 60 seconds</small>
  </>
)}
```

### 3. Connecting
A simple loading state while WebRTC negotiation happens. This usually takes just a second or two, but it's important to show something is happening.

### 4. Connected
Success! Show the peer device name and provide a disconnect button. If there's a session warning (like connection quality issues), display it here too.

```typescript
{status === 'connected' && peerName && (
  <>
    <p>Connected to: {peerName}</p>
    {sessionWarning && <div className="warning">{sessionWarning}</div>}
    <button onClick={handleDisconnect}>
      Disconnect
    </button>
  </>
)}
```

## Auto-Sync: The Magic Behind the Scenes

The real power comes from automatic synchronization. Using React's `useEffect`, I wired up listeners that sync data whenever it changes:

```typescript
// Sync transcript whenever it updates
useEffect(() => {
  if (status === 'connected' && transcript !== prevTranscriptRef.current) {
    syncTranscript(transcript);
    prevTranscriptRef.current = transcript;
  }
}, [transcript, status]);

// Sync each agent result independently
useEffect(() => {
  if (status === 'connected' && summaryResult) {
    syncAgentResult('summary', summaryResult);
  }
}, [summaryResult, status]);
```

This pattern repeats for all seven agent types (summary, action items, sentiment, questions, key points, insights, and topics). Each one syncs independently, ensuring that partial results flow to the peer device as they become available.

The `useRef` for previous transcript is crucial—it prevents redundant sync calls when other state changes trigger re-renders.

## Visual Feedback in the Header

The main page header now shows sync status at a glance:

- **Status badge**: Displays "Waiting for peer", "Connecting...", or "Connected to [Device]"
- **Sync icon button**: Grayed out when disconnected, turns green when connected
- **Click to configure**: Opens the pairing modal for managing connections

```typescript
<header>
  {status !== 'disconnected' && <SyncStatus />}
  <button
    onClick={() => setShowSyncModal(true)}
    className={status === 'connected' ? 'sync-connected' : ''}
  >
    <SyncIcon />
  </button>
</header>
```

The modal automatically closes when a connection is established, getting out of the user's way so they can focus on their work.

## Lessons Learned

### Infrastructure Pays Dividends

This session was remarkably smooth because the backend and state management were already solid. When the foundation is well-designed, wiring up the UI becomes straightforward.

### Small Inconsistency Noted

I noticed `SyncStatus.tsx` uses a default export while most components use named exports. It works fine, but consistency would be nice. I chose to leave it as-is rather than introduce unnecessary churn, but it's a reminder to establish and document conventions early.

### Progressive Enhancement

The sync feature is completely optional—the app works perfectly fine without it. This "progressive enhancement" approach meant I could add sync without touching existing functionality, reducing risk and making testing easier.

## What's Next

With the UI complete, Phase 5 is functionally done. But there's still work before this is production-ready:

1. **Deploy the signaling server** to a cloud platform (Railway or Fly.io) and update the hardcoded localhost URL
2. **Real-device testing** across different networks to verify NAT traversal works
3. **Add STUN/TURN server configuration** (currently using Google's public STUN server)
4. **Write frontend tests** for the pairing component's state transitions
5. **Consider sync indicators** in the transcript display showing which updates came from the peer device

## The Commits

All of this work is captured in commit `08fa972`, building on the Phase 5 foundation:
- `031c7df`: WebRTC module
- `be74ebd`: Signaling protocol
- `140b81a`: Integration tests
- `c564257`: Sync state management
- `997e6a7`: End-to-end tests
- `08fa972`: Sync UI (this session)

With 53 frontend tests and 43 Rust tests passing, the codebase is in good shape for the next phase of testing and deployment.

---

*This post is part of a series documenting the development of a real-time voice transcription app with device sync capabilities. The full source code will be available soon.*